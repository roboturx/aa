<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RDB: Core RDB classes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="index.html">Simple template-based relational database</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Core <a class="el" href="namespace_r_d_b.html" title="Simple template-based relational database.">RDB</a> classes </h1>  </div>
</div>
<div class="contents">
<h2><a class="anchor" id="introduction"></a>
Introduction</h2>
<p>An RDB table is an indexed collection of objects, similar to a hashed map, but with the possibility to have multiple indexes for different attributes in one table. It can be used to organize data in memory in a similar way to a relational database. Note that RDB provides no support for serializing data or for binding with an external database.</p>
<p>Many applications need to store complex data structures in memory. They often do so by using collections of objects, which in turn contain their own collections of objects, forming a tree structure of relations. The downside is that in order to find data stored on a deep level of the tree, you have to traverse through all parent branches, which may lead to inefficient and difficult to understand code.</p>
<p>The situation gets even worse if the data structure is not a tree, but contains cross-references, circular dependencies and many-to-many relations. This makes memory management difficult and error-prone, especially in a language such as C++ with no automatic garbage collection.</p>
<p>A relational database is a simple and well established model of storing data with complex relations. Databases are excellent for storing persistent data, but cannot be used for working with data which has to be stored in memory for performance reasons. Even if an application works with a database backend, it still usually maps retrieved data to collections of objects, which are subject to the problems described above.</p>
<p>The purpose of RDB is to combine the efficiency and ease of use of simple containers like lists and maps with the idea of a relational database which uses keys and indexes for modeling relations between data.</p>
<h2><a class="anchor" id="tables"></a>
Tables</h2>
<p>The RDB tables always store data by pointer, not by value. They take ownership of stored objects, meaning that they are automatically destroyed when they are removed from the table or when the table is destroyed.</p>
<p>Objects of any class can be elements of an RDB table, provided that:</p>
<ul>
<li>they have a public destructor</li>
<li>they have at least one key</li>
</ul>
<p>The key can be any <code>public</code> <code>const</code> methods returning <code>int</code>. For example:</p>
 <div class="fragment"><pre class="fragment"><span class="keyword">class </span>Project
{
<span class="keyword">public</span>:
    Project( <span class="keywordtype">int</span> projectId, <span class="keywordtype">int</span> companyId, <span class="keyword">const</span> QString&amp; name );
    ~Project();

<span class="keyword">public</span>:
    <span class="keywordtype">int</span> projectId()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_projectId; }
    <span class="keywordtype">int</span> companyId()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_companyId; }

    <span class="keywordtype">void</span> setName( <span class="keyword">const</span> QString&amp; name ) { m_name = name; }
    QString name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_name; }

<span class="keyword">private</span>:
    <span class="keywordtype">int</span> m_projectId;
    <span class="keywordtype">int</span> m_companyId;
    QString m_name;
};
</pre></div></p>
<p>The <code>Project</code> class contains two keys: <code>projectId</code> (the primary key) and <code>companyId</code> (the foreign key with a one-to-many relation). Note that keys cannot be modified once the object is inserted into a table, that's why there are no setter methods for the key attributes.</p>
<p>Tables are type-safe, which means that they store objects of a specific type. They are also const-safe; there are separate iterators and const iterators like for many containers.</p>
<p>There are three pre-defined tables with different structure of indexes:</p>
<ul>
<li>simple table (only one primary key)</li>
<li>child table (one primary key and one foreign key for a one-to-many relation)</li>
<li>cross table (primary key consists of a pair of foreign keys for a many-to-many relation)</li>
</ul>
<p>For example, a table storing objects of class <code>Project</code> shown above may look like this:</p>
<p><div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <a class="code" href="class_r_d_b_1_1_child_table.html" title="Table with two indexes for rows with a primary key and a foreign key.">RDB::ChildTable&lt;Project&gt;</a> Projects;
</pre></div></p>
<p>All tables will usually be stored as members a single class responsible for managing the data:</p>
<p><div class="fragment"><pre class="fragment">    Projects m_projects;
</pre></div></p>
<p>Before a table can be used, its indexes must be initialized:</p>
 <div class="fragment"><pre class="fragment">    m_projects.initIndex( 251, &amp;Project::projectId );
    m_projects.initParentIndex( 63, &amp;Project::companyId );
</pre></div></p>
<p>The first parameter is the size of the hash table used by the index; for simplicity RDB uses fixed size indexes. It should be a primary number close to the anticipated number of unique key values stored in the index. Collisions are resolved by chaining, which improves efficiency especially for foreign indexes which usually contain multiple occurrences of the same key value.</p>
<p>The second parameter is a pointer to the method returning the value of the key to be indexed. This method is only called when an item is inserted into the table; the index stores copies of the key values. Only integer keys can be indexed.</p>
<p>Note that for simplicity and efficiency, RDB provides no constraint checking of any kind. For example you can insert multiple items with the same primary key into a table; it's up to you to detect and handle such situations. The distinction between primary and foreign indexes is only made to improve type safety when using iterators (see <a class="el" href="rdbcore.html#indexes">Indexes and Iterators</a>).</p>
<p>You can easily create your own, more complex tables by inheriting one of the pre-defined ones and creating additional indexes, as shown in the <a class="el" href="rdbcore.html#advanced">Advanced Usage</a> section.</p>
<p>None of the RDB classes is thread-safe. When needed, you have to provide your own synchronization mechanism when accessing the data.</p>
<h2><a class="anchor" id="basic"></a>
Basic Operations</h2>
<p>To add an item to the table, use the <code>insert</code> method. For example:</p>
<p><div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> DataManager::addProject( <span class="keywordtype">int</span> companyId, <span class="keyword">const</span> QString&amp; name )
{
    <span class="keywordtype">int</span> projectId = nextId();
    m_projects.insert( <span class="keyword">new</span> Project( projectId, companyId, name ) );
    emit projectsChanged();
    <span class="keywordflow">return</span> projectId;
}
</pre></div></p>
<p>As stated above, there is no constraint checking and the method always succeeds, even if there is already another object with the same primary key value. In our example each objects gets a unique identifier, so we can be sure that cannot happen.</p>
<p>To find a single item in a table, use the <code>find</code> method. For example:</p>
<p><div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> DataManager::editProject( <span class="keywordtype">int</span> projectId, <span class="keyword">const</span> QString&amp; name )
{
    Project* project = m_projects.find( projectId );
    <span class="keywordflow">if</span> ( project ) {
        project-&gt;setName( name );
        emit projectsChanged();
    }
}
</pre></div></p>
<p>If no item with the given object is found, <code>NULL</code> is returned. Note that the <code>find</code> method returns either a constant or non-constant pointer to the object, depending if the table itself is a constant. This way you can easily access the data from outside the data manager without the risk of accidentally changing it. For example:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">const</span> Project* project = m_manager-&gt;projects()-&gt;find( m_projectId );
    <span class="keywordflow">if</span> ( project ) { 
        <span class="comment">// ...</span>
    }
</pre></div><p>To remove a single item from the table, use the <code>remove</code> method. Child and cross tables also provide methods which remove all items with the specified value of a foreign key. For example:</p>
<p><div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> DataManager::removeProject( <span class="keywordtype">int</span> projectId )
{
    m_projects.remove( projectId );
    m_members.removeSecond( projectId );
    emit projectsChanged();
}
</pre></div></p>
<p>Note that removed objects are automatically deleted. If no object with the given key exists in the table, nothing happens.</p>
<h2><a class="anchor" id="indexes"></a>
Indexes and Iterators</h2>
<p>RDB provides a number of index classes, which are used to store a reference to a single index of a table. Since these classes are basically wrappers on a single pointer, they can be efficiently passed by value and copied.</p>
<p>There are two logical types of indexes: unique and foreign. They are used in a different way, but there is no technical difference between them, they are only distinguished to make code more descriptive. The <a class="el" href="class_r_d_b_1_1_unique_index.html" title="Unique key index for non-const rows.">RDB::UniqueIndex</a> has the <code>find</code> method used to retrieve a single item, whereas the <a class="el" href="class_r_d_b_1_1_foreign_index.html" title="Foreign key index for non-const rows.">RDB::ForeignIndex</a> can be used together with a foreign iterator to retrieve all items matching a key value.</p>
<p>There is also a special index called <a class="el" href="class_r_d_b_1_1_unique_pair_index.html" title="Unique pair of foreign key indexes for non-const rows.">RDB::UniquePairIndex</a> which consists of a pair of foreign indexes forming a single unique key. It is used by the <a class="el" href="class_r_d_b_1_1_cross_table.html" title="Table for rows with two foreign keys which form a unique pair.">RDB::CrossTable</a> and usually represents a many-to-many relation. It provides a <code>find</code> method which returns a single item and <code>first</code> and <code>second</code> methods which return the foreign indexes. The pair index cannot be used directly with an iterator.</p>
<p>The <a class="el" href="class_r_d_b_1_1_index_iterator.html" title="Non-const iterator for all rows in an index.">RDB::IndexIterator</a> can be used with both unique and foreign indexes to iterate all items in the table. For example:</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="class_r_d_b_1_1_index_iterator.html" title="Non-const iterator for all rows in an index.">RDB::IndexIterator&lt;Project&gt;</a> it( m_projects.index() );
    <span class="keywordflow">while</span> ( it.next() ) {
        Project* project = it.get();
        <span class="comment">// ...</span>
    }
</pre></div><p>Th <a class="el" href="class_r_d_b_1_1_foreign_iterator.html" title="Non-const iterator for rows with a given foreign key value.">RDB::ForeignIterator</a> can be used only with foreign indexes to iterate all items with the matching value of the foreign key in an efficient way, taking advantage of the hashed index. For example:</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="class_r_d_b_1_1_foreign_iterator.html" title="Non-const iterator for rows with a given foreign key value.">RDB::ForeignIterator&lt;Project&gt;</a> it( m_projects.parentIndex(), companyId );
    <span class="keywordflow">while</span> ( it.next() ) {
        Project* project = it.get();
        <span class="comment">// ...</span>
    }
</pre></div><p>The order in which items are iterated is unspecified. You can use the <a class="el" href="rdbcore.html#utilities">utility functions</a> to sort items according to some criteria.</p>
<p>Each index and iterator has both a constant and a non-constant variant. Constant indexes and iterators don't allow to modify the items stored in the table. A non-constant index can be implicitly converted to a constant one, but the opposite conversion is not allowed. The constant variants of the iterators are called <a class="el" href="class_r_d_b_1_1_index_const_iterator.html" title="Constant iterator for all rows in an index.">RDB::IndexConstIterator</a> and <a class="el" href="class_r_d_b_1_1_foreign_const_iterator.html" title="Constant iterator for rows with a given foreign key value.">RDB::ForeignConstIterator</a>.</p>
<p>Indexes and iterators are specialized by the class of the items stored in the table. There are also generic indexes, specialized with the <code>void</code> type, which provide access to key values, but not to the items. They are used for example by the <a class="el" href="class_r_d_b_1_1_table_item_model.html" title="Item model populated with items from RDB tables.">RDB::TableItemModel</a> to iterate over tables of different types. A specialized index can be implicitly converted to a generic one, but the opposite conversion is not allowed.</p>
<p>Iterators become invalid when items are inserted or removed from the table. For example, the effect of simultaneously iterating and removing items from the same table is undefined.</p>
<h2><a class="anchor" id="advanced"></a>
Advanced Usage</h2>
<p>If you need to create table with more indexes than the pre-defined ones, you can do so by inheriting the table class and implementing methods for initializing and accessing those indexes. Usually your table will inherit from one of the three existing tables and create additional indexes. Alternatively it can inherit <a class="el" href="class_r_d_b_1_1_table_base.html" title="Base of all table templates.">RDB::TableBase</a> directly.</p>
<p>Example of adding a third index to an <a class="el" href="class_r_d_b_1_1_child_table.html" title="Table with two indexes for rows with a primary key and a foreign key.">RDB::ChildTable</a>:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ROW, <span class="keywordtype">int</span> DIMS = 3&gt;
<span class="keyword">class </span>MyTable : <span class="keyword">public</span> RDB::ChildTable&lt;ROW, DIMS&gt;
{
    <span class="keyword">typedef</span> <a class="code" href="class_r_d_b_1_1_child_table.html" title="Table with two indexes for rows with a primary key and a foreign key.">RDB::ChildTable&lt;ROW, DIMS&gt;</a> Base;
<span class="keyword">public</span>:
    MyTable() { }

<span class="keyword">public</span>:
    <span class="keywordtype">void</span> initThirdIndex( <span class="keywordtype">int</span> size, <span class="keyword">typename</span> Base::KeyMethod keyMethod )
    {
        init( Base::data( 2 ), size, keyMethod );
    }

    <a class="code" href="class_r_d_b_1_1_foreign_index.html" title="Foreign key index for non-const rows.">RDB::ForeignIndex&lt;ROW&gt;</a> thirdIndex()
    {
        <span class="keywordflow">return</span> <a class="code" href="class_r_d_b_1_1_foreign_index.html" title="Foreign key index for non-const rows.">RDB::ForeignIndex&lt;ROW&gt;</a>( Base::data( 2 ) );
    }

    <a class="code" href="class_r_d_b_1_1_foreign_const_index.html" title="Foreign key index for constant rows.">RDB::ForeignConstIndex&lt;ROW&gt;</a> thirdIndex()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> <a class="code" href="class_r_d_b_1_1_foreign_const_index.html" title="Foreign key index for constant rows.">RDB::ForeignConstIndex&lt;ROW&gt;</a>( Base::data( 2 ) );
    }

    <span class="keywordtype">void</span> removeThird( <span class="keywordtype">int</span> thirdKey )
    {
        Base::removeBuckets( Base::data( 2 ), thirdKey );
    }

<span class="keyword">private</span>:
    MyTable( <span class="keyword">const</span> MyTable&amp; );
    MyTable&amp; operator =( <span class="keyword">const</span> MyTable&amp; );
};
</pre></div><p>The second parameter of all table templates, called <code>DIMS</code>, specifies the number of indexes, so that derived classes can easily add more indexes. The <code>data</code> method, defined in <a class="el" href="class_r_d_b_1_1_table_base.html" title="Base of all table templates.">RDB::TableBase</a>, returns an internal pointer to the given index data, which can be wrapped in an index class.</p>
<p>The <code>Base</code> type is used to explicitly qualify inherited symbols; otherwise the code would break with standard C++ two-stage name lookup, for example when compiled using <code>g++</code>. The copy constructor and assignment operator is made private to prevent accidentally copying the table.</p>
<p>Look at the implementation of <a class="el" href="class_r_d_b_1_1_simple_table.html" title="Table with one index for rows with a single primary key.">RDB::SimpleTable</a>, <a class="el" href="class_r_d_b_1_1_child_table.html" title="Table with two indexes for rows with a primary key and a foreign key.">RDB::ChildTable</a> and <a class="el" href="class_r_d_b_1_1_cross_table.html" title="Table for rows with two foreign keys which form a unique pair.">RDB::CrossTable</a> to see how primary, foreign and pair indexes are created and how various remove methods can be implemented.</p>
<h2><a class="anchor" id="utilities"></a>
Utilities</h2>
<p>There are some helper functions defined in the <code>&lt;rdb/utilities.h&gt;</code> header file which simplify retrieving items sorted using an attribute. Unlike the core RDB classes, the utility functions depend on the Qt framework.</p>
<p>The first function, <a class="el" href="namespace_r_d_b.html#afcda2e75b21b01935ca6f0e14d809211" title="Sort rows of a table using given property.">RDB::sortRows</a>, takes any method returning a value which can be compared using operator &lt; as the sort order. The second function, <a class="el" href="namespace_r_d_b.html#a51e2135c4bceb17986f7f70359dcd3ec" title="Sort rows of a table using given property.">RDB::localeAwareSortRows</a>, takes a method returning a string which is compared using QString::localeAwareCompare. These functions work with both index and foreign iterators and return a QList of pointers to constant items.</p>
<p>For example, you can use the following code to get all projects sorted by name:</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="class_r_d_b_1_1_index_const_iterator.html" title="Constant iterator for all rows in an index.">RDB::IndexConstIterator&lt;Project&gt;</a> it( m_projects.index() );
    QList&lt;const Project*&gt; projects = <a class="code" href="namespace_r_d_b.html#a51e2135c4bceb17986f7f70359dcd3ec" title="Sort rows of a table using given property.">RDB::localeAwareSortRows</a>( it, &amp;Project::name );
</pre></div><p>The <a class="el" href="namespace_r_d_b.html#aff46f6d474ed0cf3083c73f4eec0102c" title="Find a row with given value of a non-indexed property in a table.">RDB::findRow</a> function returns the first row matching a given condition or <code>NULL</code> if such row was not found. It takes a pointer to a method returning a property and a value of the property. You can use it in the following way:</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="class_r_d_b_1_1_index_const_iterator.html" title="Constant iterator for all rows in an index.">RDB::IndexConstIterator&lt;Project&gt;</a> it( m_projects.index() );
    <span class="keyword">const</span> Project* project = <a class="code" href="namespace_r_d_b.html#aff46f6d474ed0cf3083c73f4eec0102c" title="Find a row with given value of a non-indexed property in a table.">RDB::findRow</a>( it, &amp;Project::name, <span class="stringliteral">&quot;First Project&quot;</span> );
</pre></div> </div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Apr 24 2012 22:23:19 for RDB by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
