<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RDB: Adapters for the Qt Model/View architecture</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="index.html">Simple template-based relational database</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Adapters for the Qt Model/View architecture </h1>  </div>
</div>
<div class="contents">
<h2><a class="anchor" id="introduction"></a>
Introduction</h2>
<p>The RDB package contains adapter classes for using tables with the Qt Model/View architecture in an easy and comfortable way. This is useful if your application needs to displays various lists and trees of data stored in RDB tables. The adapter model automatically populates the view, and also provides support for automatic sorting and filtering and makes customizing columns in the view easy.</p>
<p>The Model/View architecture in Qt is an excellent and powerful solution, but implementing a model from scratch is not very comfortable. One of the problems is that the indexes used to identify cells are based on the physical row and column number in the view, which has to be translated to the appropriate item of data. This can be difficult when rows can be sorted, columns can be reordered and especially if the view is a tree with multiple levels of items.</p>
<p>The <a class="el" href="class_r_d_b_1_1_table_item_model.html" title="Item model populated with items from RDB tables.">RDB::TableItemModel</a> class solves this problem by acting like an additional layer between QAbstractItemModel and simplified models called table models. Table models operate on item identifiers (which simply correspond to keys in the RDB tables) and column identifiers, without having to know the layout of rows and columns in the view. In addition, each table model is associated with a single level of items in the tree. This way you can, for example, create a list of all persons and a tree of persons grouped by company, and reuse the same table model in both these views.</p>
<h2><a class="anchor" id="models"></a>
Implementing Table Models</h2>
<p>To create a table model, you have to inherit the <a class="el" href="class_r_d_b_1_1_abstract_table_model.html" title="Abstract model providing information about rows of a table.">RDB::AbstractTableModel</a> class and implement a few virtual methods. The minimal implementation consists of just two methods:</p>
<div class="fragment"><pre class="fragment">    QString columnName( <span class="keywordtype">int</span> column ) <span class="keyword">const</span>
    QString text( <span class="keywordtype">int</span> <span class="keywordtype">id</span>, <span class="keywordtype">int</span> column ) <span class="keyword">const</span>
</pre></div><p>The <code>id</code> parameter is the primary key of the item stored in the table. The <code>column</code> parameter is the logical identifier of the column. Usually you will create an <code>enum</code> containing all column identifiers, for example:</p>
 <div class="fragment"><pre class="fragment"><span class="keyword">enum</span> Columns
{
    Column_Name,
    Column_Address,
    Column_Phone
};
</pre></div></p>
<p>A typical implementation of the <code>columnName</code> method looks like this:</p>
 <div class="fragment"><pre class="fragment">QString BaseTableModel::columnName( <span class="keywordtype">int</span> column )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">switch</span> ( column ) {
        <span class="keywordflow">case</span> Column_Name:
            <span class="keywordflow">return</span> tr( <span class="stringliteral">&quot;Name&quot;</span> );
        <span class="keywordflow">case</span> Column_Address:
            <span class="keywordflow">return</span> tr( <span class="stringliteral">&quot;Address&quot;</span> );
        <span class="keywordflow">case</span> Column_Phone:
            <span class="keywordflow">return</span> tr( <span class="stringliteral">&quot;Phone&quot;</span> );
        <span class="keywordflow">default</span>:
            <span class="keywordflow">return</span> QString();
    }
}
</pre></div></p>
<p>Implementation of the <code>text</code> method may look like this:</p>
<p><div class="fragment"><pre class="fragment">QString CompaniesModel::text( <span class="keywordtype">int</span> <span class="keywordtype">id</span>, <span class="keywordtype">int</span> column )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keyword">const</span> Company* company = dataManager()-&gt;companies()-&gt;find( <span class="keywordtype">id</span> );
    <span class="keywordflow">if</span> ( !company )
        <span class="keywordflow">return</span> QString();

    <span class="keywordflow">switch</span> ( column ) {
        <span class="keywordflow">case</span> Column_Name:
            <span class="keywordflow">return</span> company-&gt;name();
        <span class="keywordflow">case</span> Column_Address:
            <span class="keywordflow">return</span> company-&gt;address();
        <span class="keywordflow">default</span>:
            <span class="keywordflow">return</span> QString();
    }
}
</pre></div></p>
<p>There are two additional methods which can be implemented if needed: <code>icon</code> method for retrieving item's image and <code>tooTip</code> for retrieving its tool-tip. The default implementations return an empty pixmap and empty string, respectively.</p>
<p>The last method, called <code>compare</code>, can be used for defining sorting criteria for the given column. The default implementation simply compares the strings using <code>localeAwareCompare</code> (see <a class="el" href="modelview.html#sorting">Sorting and Filtering</a> section below for more details).</p>
<h2><a class="anchor" id="itemmodel"></a>
Configuring the Table Item Model</h2>
<p>In order to populate the top level items in the table items model, call <code>setRootTableModel</code> with an instance of the table model which provides information about these items and a unique index of the table you want to use. Keys from the index will be used as item identifiers passed to the table model. For example:</p>
 <div class="fragment"><pre class="fragment">    projectsModel-&gt;setRootTableModel( <span class="keyword">new</span> CompaniesModel( m_manager ), m_manager-&gt;companies()-&gt;index() );
</pre></div></p>
<p>Alternatively, you can add only items which match the given value of the foreign key by specifying an additional foreign index and the key value. This way, for example, you could display a list of all project items belonging to a particular company:</p>
<div class="fragment"><pre class="fragment">    projectsModel-&gt;setRootTableModel( <span class="keyword">new</span> ProjectsModel( m_manager ), m_manager-&gt;projects()-&gt;index(),
        m_manager-&gt;projects()-&gt;parentIndex(), companyId ); 
</pre></div><p>In this case, the first index doesn't need to be unique. This way many-to-many relationships can also be handled; for example, you could display all persons which are members of a particular project or all projects of a particular person (using the Members table which contains two foreign keys for assigning projects to persons). However, both indexes must belong to the same table.</p>
<p>To add more levels of hierarchy, call <code>addChildTableModel</code> as many times as you need with an instance of the appropriate table model for the given level of hierarchy and two indexes. The first index is used to read item identifiers which are passed to the table model. The second index is used to match items with their parent items. For example:</p>
 <div class="fragment"><pre class="fragment">    projectsModel-&gt;setRootTableModel( <span class="keyword">new</span> CompaniesModel( m_manager ), m_manager-&gt;companies()-&gt;index() );
    projectsModel-&gt;addChildTableModel( <span class="keyword">new</span> ProjectsModel( m_manager ),
        m_manager-&gt;projects()-&gt;index(), m_manager-&gt;projects()-&gt;parentIndex() );
    projectsModel-&gt;addChildTableModel( <span class="keyword">new</span> PersonsModel( m_manager ),
        m_manager-&gt;members()-&gt;index().first(), m_manager-&gt;members()-&gt;index().second() );
</pre></div></p>
<p>The values in the parent index of the <em>Projects</em> table are compared with the primary index of the <em>Companies</em> table, so projects are grouped under their corresponding companies. The values of the second index of the <em>Members</em> table (which store project identifiers) are compared with the primary index of the <em>Companies</em> table and the person identifiers (stored in the first index) are passed to the persons model.</p>
<p>The table item model is completely independent of the types of table. All methods described above use the typeless specialization of indexes. There is no validation if the table model and the index refer to the same table. In fact they don't even have to; in the above example, the <em>Persons</em> model is used with an index of the <em>Members</em> table, which is perfectly valid, since the <code>Members</code> table doesn't represent a separate entity, but is used to model a many-to-many relation between <code>Persons</code> and <code>Projects</code>.</p>
<p>The last step of defining a table item model is to set the list of column which will be displayed in the view by calling the <code>setColumns</code> method. For example:</p>
 <div class="fragment"><pre class="fragment">    QList&lt;int&gt; columns;
    columns &lt;&lt; Column_Name &lt;&lt; Column_Address &lt;&lt; Column_Phone;
    projectsModel-&gt;setColumns( columns );
</pre></div></p>
<h2><a class="anchor" id="sorting"></a>
Sorting and Filtering</h2>
<p>All you have to do to enable sorting the view by any column is to set the <code>sortingEnabled</code> property of the QTreeView. You can also set the initial sorting order, for example:</p>
<p><div class="fragment"><pre class="fragment">    m_ui.projectsView-&gt;sortByColumn( 0, Qt::AscendingOrder );
</pre></div></p>
<p>By default, items are sorted in alphabetic, case-insensitive order, by comparing the values returned from the <code>text</code> method for the sorting column using the QString::localeAwareCompare function. You can change this behavior by overriding the <code>compare</code> method in the table model. This way you can, for example, sort items by numbers, dates or other kind of attributes.</p>
<p>Note that Qt 4.4.0 has a bug which makes sorting the model not preserve the expanded state of tree items correctly. It's reported to Trolltech and will probably be fixed in the next release. In case you are compiling Qt from sources, a patch is provided with this package.</p>
<p>The table item model also provides a very easy to use mechanism of filtering rows. In order to implement a filtering algorithm, inherit the <a class="el" href="class_r_d_b_1_1_abstract_row_filter.html" title="Abstract filter for filtering table rows.">RDB::AbstractRowFilter</a> class and implement the <code>filter</code> method, for example:</p>
 <div class="fragment"><pre class="fragment"><span class="keywordtype">bool</span> PersonsFilter::filterRow( <span class="keywordtype">int</span> <span class="keywordtype">id</span> )
{
    <span class="keywordflow">if</span> ( m_nameFilter.isEmpty() )
        <span class="keywordflow">return</span> <span class="keyword">true</span>;

    DataManager* dataManager = (DataManager*)parent();
    <span class="keyword">const</span> Person* person = dataManager-&gt;persons()-&gt;find( <span class="keywordtype">id</span> );
    QString name = person ? person-&gt;name() : QString();

    <span class="keywordflow">return</span> name.contains( m_nameFilter, Qt::CaseInsensitive );
}
</pre></div></p>
<p>Note that only the top level rows can be filtered this way, so this feature is mostly usable with plain lists, not with trees.</p>
<p>It is possible to find the index of the cell with given row and column identifiers using the <code>findCell</code> method.</p>
<h2><a class="anchor" id="updating"></a>
Updating the Model</h2>
<p>The table item model is filled with data immediately when table models are added to it. However, it must be notified of any changes made to the data. For that purpose, the <a class="el" href="class_r_d_b_1_1_table_item_model.html" title="Item model populated with items from RDB tables.">RDB::TableItemModel</a> class has a public slot called <code>updateData</code> which rebuilds the internal structures and updates the view.</p>
<p>For simplicity, <a class="el" href="class_r_d_b_1_1_abstract_table_model.html" title="Abstract model providing information about rows of a table.">RDB::AbstractTableModel</a> has a signal called <code>dataChanged</code> which is automatically connected to the <code>updateData</code> slot when the table model is added to the table item model. It is up to the implementation of the table model to emit this signal as necessary.</p>
<p>The update can also be triggered from another place. For example, in the demo application, the <code>DataManager</code> class has emits signals when some data was added, removed or modified. These signals are connected directly to the <code>updateData</code> slot of the appropriate model:</p>
 <div class="fragment"><pre class="fragment">    connect( m_manager, SIGNAL( projectsChanged() ), projectsModel, SLOT( updateData() ) );
    connect( m_manager, SIGNAL( personsChanged() ), personsModel, SLOT( updateData() ) );
</pre></div></p>
<p>Note that every time this function is called, the entire model and view is updated, which can be a costly operation for large number of items. Design the updating algorithm in a way that prevents calling it multiple times during a single operation, for example when multiple items are added or removed.</p>
<p>The <a class="el" href="class_r_d_b_1_1_abstract_row_filter.html" title="Abstract filter for filtering table rows.">RDB::AbstractRowFilter</a> class also has a signal called <code>conditionsChanged</code> which is automatically connected to the <code>updateData</code> slot when the filter is added to the table item model. The implementation of the filter can emit it when necessary to force updating the model. </p>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Apr 24 2012 22:23:18 for RDB by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
