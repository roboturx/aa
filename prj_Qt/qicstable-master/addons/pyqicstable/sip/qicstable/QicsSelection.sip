// QicsSelection.sip generated by MetaSIP on Thu Aug 26 12:32:36 2010
//
// This file is part of the qicstable Python extension module.
//
// Copyright (c) 2004 - 2014
// 	Integrated Computer Solutions, Inc. <info@ics.com>
//
// This file is part of PyQicsTable.
//
// This copy of PyQicsTable is licensed for use under the terms of the
// PyQicsTable Commercial License Agreement version ICS-2.6.  See the file
// LICENSE for more details.
//
// PyQicsTable is supplied WITHOUT ANY WARRANTY; without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


class QicsSelection
{
%TypeHeaderCode
#include <QicsSelection.h>
%End

public:
    QicsSelection();
    QicsSelection(int, int, int, int, bool = true);
    QicsSelection(const QicsSelection &);
    void setSelected(bool);
    bool selected() const;
    bool isValid() const;
    void setAnchorRow(int);
    void setAnchorColumn(int);
    void setAnchorCell(int, int);
    void setEndRow(int);
    void setEndColumn(int);
    void setEndCell(int, int);
    int anchorRow() const;
    int anchorColumn() const;
    int endRow() const;
    int endColumn() const;
    int topRow() const;
    int leftColumn() const;
    int bottomRow() const;
    int rightColumn() const;
    int numColumns() const;
    int numRows() const;
    void setEntireRow(int);
    void setEntireColumn(int);
    bool intersects(const QicsSelection &);
    QicsSelection intersect(const QicsSelection &);

//    bool operator==(const QicsSelection &) const;
//    bool operator!=(const QicsSelection &) const;
};

class QicsSelectionList / NoDefaultCtors /
{
%TypeHeaderCode
#include <QicsSelection.h>
%End

public:
    QicsSelectionList(QicsDataModel *dm);
    void setDataModel(QicsDataModel *dm);
    QicsDataModel *dataModel() const;
    bool isCellSelected(int, int) const;
    bool isRowSelected(int) const;
    bool isColumnSelected(int) const;

// QicsSelectionList API extensions to allow it to behave much more like a
// Python list.

public:
    int __len__();
%MethodCode
        sipRes = sipCpp -> count();
%End

    void __setitem__(int, const QicsSelection &);
%MethodCode
        int len = sipCpp -> count();

        if ((a0 = sipConvertFromSequenceIndex(a0, len)) < 0)
            sipIsErr = 1;
        else
            (*sipCpp)[a0] = *a1;
%End

    void __setitem__(SIP_PYSLICE, const QicsSelectionList &);
%MethodCode
        SIP_SSIZE_T len, start, stop, step, slicelength;

        len = sipCpp -> count();

        if (sipConvertFromSliceObject(a0, len, &start, &stop, &step, &slicelength) < 0)
            sipIsErr = 1;
        else
        {
            int vlen = a1 -> count();

            if (vlen != slicelength)
            {
                sipBadLengthForSlice(vlen, slicelength);
                sipIsErr = 1;
            }
            else
            {
                QicsSelectionList::ConstIterator it = a1 -> begin();

                for (int i = 0; i < slicelength; ++i)
                {
                    (*sipCpp)[start] = *it;
                    start += step;
                    ++it;
                }
            }
        }
%End

    void __delitem__(int);
%MethodCode
        int len = sipCpp -> count();

        if ((a0 = sipConvertFromSequenceIndex(a0, len)) < 0)
            sipIsErr = 1;
        else
            sipCpp -> erase(sipCpp -> begin() + a0);
%End

    void __delitem__(SIP_PYSLICE);
%MethodCode
        SIP_SSIZE_T len, start, stop, step, slicelength;

        len = sipCpp -> count();

        if (sipConvertFromSliceObject(a0, len, &start, &stop, &step, &slicelength) < 0)
            sipIsErr = 1;
        else
            for (int i = 0; i < slicelength; ++i)
            {
                sipCpp -> erase(sipCpp -> begin() + start);
                start += step - 1;
            }
%End

    QicsSelection operator[](int);
%MethodCode
    int len = sipCpp -> count();

    if ((a0 = sipConvertFromSequenceIndex(a0, len)) < 0)
        sipIsErr = 1;
    else
        sipRes = new QicsSelection((*sipCpp)[a0]);
%End

    QicsSelectionList operator[](SIP_PYSLICE);
%MethodCode
        SIP_SSIZE_T len, start, stop, step, slicelength;

        len = sipCpp -> count();

        if (sipConvertFromSliceObject(a0, len, &start, &stop, &step, &slicelength) < 0)
            sipIsErr = 1;
        else
        {
            sipRes = new QicsSelectionList(sipCpp -> dataModel());

            for (int i = 0; i < slicelength; ++i)
            {
                sipRes -> append((*sipCpp)[start]);
                start += step;
            }
        }
%End

    int __contains__(const QicsSelection &);
%MethodCode
        sipRes = 0;

        for (QicsSelectionList::size_type i = 0; i < sipCpp -> count(); ++i)
            if ((*sipCpp)[i] == *a0)
            {
                sipRes = 1;
                break;
            }
%End

};

