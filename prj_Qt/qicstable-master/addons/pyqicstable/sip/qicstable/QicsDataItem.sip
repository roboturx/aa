// QicsDataItem.sip generated by MetaSIP on Thu Aug 26 12:32:36 2010
//
// This file is part of the qicstable Python extension module.
//
// Copyright (c) 2004 - 2014
// 	Integrated Computer Solutions, Inc. <info@ics.com>
//
// This file is part of PyQicsTable.
//
// This copy of PyQicsTable is licensed for use under the terms of the
// PyQicsTable Commercial License Agreement version ICS-2.6.  See the file
// LICENSE for more details.
//
// PyQicsTable is supplied WITHOUT ANY WARRANTY; without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


%ModuleHeaderCode
#include <QicsDataItem.h>
%End


typedef unsigned int QicsDataItemType;
const QicsDataItemType QicsDataItem_UserDefined;
const QicsDataItemType QicsDataItem_Int;
const QicsDataItemType QicsDataItem_Long;
const QicsDataItemType QicsDataItem_Float;
const QicsDataItemType QicsDataItem_Double;
const QicsDataItemType QicsDataItem_String;
const QicsDataItemType QicsDataItem_Date;
const QicsDataItemType QicsDataItem_Time;
const QicsDataItemType QicsDataItem_DateTime;
typedef QicsDataItem * (*QicsDataItemParser)(const QString &);
typedef QicsDataItem * (*QicsDataItemDecoder)(QDataStream &);

class QicsDataItem : Qics
{
%TypeHeaderCode
#include <QicsDataItem.h>
%End

%TypeCode
#include <QList>


// A helper class to hold the Python callable objects for a type and manage
// their reference counts.
class PyQicsTable_typeHandlers
{
public:
    PyQicsTable_typeHandlers(const QString &tname, PyObject *psr, PyObject *dcdr)
    {
        type = tname;
        parser = psr;
        decoder = dcdr;

        Py_INCREF(parser);
        Py_INCREF(decoder);
    }

    ~PyQicsTable_typeHandlers()
    {
        Py_DECREF(parser);
        Py_DECREF(decoder);
    }

    QString type;
    PyObject *parser, *decoder;
};


// This is the list of Python handlers for each type.
static QList<PyQicsTable_typeHandlers *> PyQicsTable_typeList;


// This is the C++ function that will dispatch to the different Python parsers.
static QicsDataItem *PyQicsTable_typeParser(const QString &s)
{
    int iserr = 0;
    QicsDataItem *di = 0;

	for (int i = 0; i < PyQicsTable_typeList.count() && di && !iserr; ++i)
    {
		PyQicsTable_typeHandlers *th = PyQicsTable_typeList.at(i);
        QString scopy(s);

        SIP_BLOCK_THREADS

        // We can't enforce const so we wrap a new copy each time.
        PyObject *args = sipBuildResult(NULL, "(P)", &scopy, sipClass_QString);

        if (args != NULL)
        {
            PyObject *robj = PyObject_CallObject(th -> parser, args);

            Py_DECREF(args);

            if (robj != NULL)
            {
#if SIP_VERSION < 0x040800
                if (robj != Py_None && (di = (QicsDataItem *)sipForceConvertTo_QicsDataItem(robj, &iserr)) != NULL)
                        sipTransfer(robj, 1);
#else
                if (robj != Py_None && (di = (QicsDataItem *)sipConvertToInstance(robj, sipClass_QicsDataItem, NULL, SIP_NO_CONVERTORS, NULL, &iserr)) != NULL)
                        sipTransferTo(robj, robj);
#endif
                Py_DECREF(robj);
            }
            else
                iserr = 1;
        }
        else
            iserr = 1;

        if (iserr)
            PyErr_Print();

        SIP_UNBLOCK_THREADS
    }

    return di;
}


// This is the C++ function that will dispatch to the correct Python decoder.
static QicsDataItem *PyQicsTable_typeDecoder(QDataStream &ds, const QString &tname)
{
	for (int i = 0; i < PyQicsTable_typeList.count(); ++i) {
		PyQicsTable_typeHandlers *th = PyQicsTable_typeList.at(i);
        if (th -> type == tname)
        {
            int iserr = 0;
            QicsDataItem *di = 0;

            SIP_BLOCK_THREADS

            PyObject *args = sipBuildResult(NULL, "(M)", &ds, sipClass_QDataStream);

            if (args != NULL)
            {
                PyObject *robj = PyObject_CallObject(th -> decoder, args);

                Py_DECREF(args);

                if (robj != NULL)
                {
#if SIP_VERSION < 0x040800
					if (robj != Py_None && (di = (QicsDataItem *)sipForceConvertTo_QicsDataItem(robj, &iserr)) != NULL)
                        sipTransfer(robj, 1);
#else
					if (robj != Py_None && (di = (QicsDataItem *)sipConvertToInstance(robj, sipClass_QicsDataItem, NULL, SIP_NO_CONVERTORS, NULL, &iserr)) != NULL)
						sipTransferTo(robj, robj);
#endif
                    Py_DECREF(robj);
                }
                else
                    iserr = 1;
            }
            else
                iserr = 1;

            if (iserr)
                PyErr_Print();

            SIP_UNBLOCK_THREADS

            return di;
        }
	}
    // No decoder registered for the type.
    return 0;
}
%End

%ConvertToSubClassCode
    // Convert a QicsDataItem to a more specific instance if possible.

    switch (sipCpp -> type())
    {
    case QicsDataItem_Int:
        sipClass = sipClass_QicsDataInt;
        break;

    case QicsDataItem_Long:
        sipClass = sipClass_QicsDataLong;
        break;

    case QicsDataItem_Float:
        sipClass = sipClass_QicsDataFloat;
        break;

    case QicsDataItem_Double:
        sipClass = sipClass_QicsDataDouble;
        break;

    case QicsDataItem_String:
        sipClass = sipClass_QicsDataString;
        break;

    case QicsDataItem_Date:
        sipClass = sipClass_QicsDataDate;
        break;

    case QicsDataItem_Time:
        sipClass = sipClass_QicsDataTime;
        break;

    case QicsDataItem_DateTime:
        sipClass = sipClass_QicsDataDateTime;
        break;

    default:
        sipClass = NULL;
    };
%End

public:
    QicsDataItem();
    virtual QicsDataItem *create() const = 0 /Factory/;
    virtual QicsDataItem *clone() const = 0 /Factory/;
    virtual ~QicsDataItem();
    virtual bool setString(const QString &) = 0;
    virtual const QString string() const = 0;
    virtual double number(bool *ok = 0) const = 0;
    virtual QicsDataItemType type() const = 0;
    virtual QString typeString() const = 0;
    virtual QString format(const char *) const;
    virtual int compareTo(const QicsDataItem &) const;
    virtual void encode(QDataStream &) const = 0;
    static QicsDataItem *fromString(const QString &);
    static QicsDataItem *decode(QDataStream &);
    static void registerType(const QString, SIP_PYCALLABLE, SIP_PYCALLABLE);
%MethodCode
		for (int i = 0; i < PyQicsTable_typeList.count(); ++i) {
			PyQicsTable_typeHandlers *th = PyQicsTable_typeList.at(i);
            if (th -> type == *a0)
            {
                //delete PyQicsTable_typeList.take();
				delete th;
				PyQicsTable_typeList.removeAt(i);
                break;
            }
		}

        // Save these callables.
        PyQicsTable_typeList.append(new PyQicsTable_typeHandlers(*a0, a1, a2));

        // Register the C++ dispatchers.
        Py_BEGIN_ALLOW_THREADS

        QicsDataItemParser psr;
        QicsDataItemDecoderWithType dcdr;

        // Only register the C++ dispatcher if there is a corresponding Python
        // callable.
        psr = (a1 != Py_None) ? PyQicsTable_typeParser : 0;
        dcdr = (a2 != Py_None) ? PyQicsTable_typeDecoder : 0;

        QicsDataItem::registerTypeI(*a0, psr, dcdr);
        Py_END_ALLOW_THREADS
%End
};

typedef int (*DataItemComparator)(const QicsDataItem *, const QicsDataItem *);

class QicsDataInt : QicsDataItem
{
%TypeHeaderCode
#include <QicsDataItem.h>
%End

public:
    QicsDataInt();
    QicsDataInt(int);
    QicsDataInt(const QicsDataInt &);
    virtual QicsDataItem *create() const /Factory/;
    virtual QicsDataItem *clone() const /Factory/;
    virtual QicsDataItemType type() const;
    static QString typeName();
    virtual QString typeString() const;
    virtual const QString string() const;
    virtual double number(bool *ok = 0) const;
    virtual bool setString(const QString &);
    int data() const;
    void setData(int);
    virtual QString format(const char *) const;
    virtual int compareTo(const QicsDataItem &) const;
    virtual void encode(QDataStream &) const;
    static QicsDataItem *fromString(const QString &);
    static QicsDataItem *decode(QDataStream &);
};

class QicsDataLong : QicsDataItem
{
%TypeHeaderCode
#include <QicsDataItem.h>
%End

public:
    QicsDataLong();
    QicsDataLong(long);
    QicsDataLong(const QicsDataLong &);
    virtual QicsDataItem *create() const /Factory/;
    virtual QicsDataItem *clone() const /Factory/;
    virtual QicsDataItemType type() const;
    static QString typeName();
    virtual QString typeString() const;
    virtual const QString string() const;
    virtual bool setString(const QString &);
    virtual double number(bool *ok = 0) const;
    long data() const;
    void setData(long);
    virtual QString format(const char *) const;
    virtual int compareTo(const QicsDataItem &) const;
    virtual void encode(QDataStream &) const;
    static QicsDataItem *fromString(const QString &);
    static QicsDataItem *decode(QDataStream &);
};

class QicsDataFloat : QicsDataItem
{
%TypeHeaderCode
#include <QicsDataItem.h>
%End

public:
    QicsDataFloat();
    QicsDataFloat(float);
    QicsDataFloat(const QicsDataFloat &);
    virtual QicsDataItem *create() const /Factory/;
    virtual QicsDataItem *clone() const /Factory/;
    virtual QicsDataItemType type() const;
    static QString typeName();
    virtual QString typeString() const;
    virtual const QString string() const;
    virtual bool setString(const QString &);
    virtual double number(bool *ok = 0) const;
    float data() const;
    void setData(float);
    virtual QString format(const char *) const;
    virtual int compareTo(const QicsDataItem &) const;
    virtual void encode(QDataStream &) const;
    static QicsDataItem *fromString(const QString &);
    static QicsDataItem *decode(QDataStream &);
};

class QicsDataDouble : QicsDataItem
{
%TypeHeaderCode
#include <QicsDataItem.h>
%End

public:
    QicsDataDouble();
    QicsDataDouble(double);
    QicsDataDouble(const QicsDataDouble &);
    virtual QicsDataItem *create() const /Factory/;
    virtual QicsDataItem *clone() const /Factory/;
    static QString typeName();
    virtual QString typeString() const;
    virtual QicsDataItemType type() const;
    virtual const QString string() const;
    virtual bool setString(const QString &);
    virtual double number(bool *ok = 0) const;
    double data() const;
    void setData(double);
    virtual QString format(const char *) const;
    virtual int compareTo(const QicsDataItem &) const;
    virtual void encode(QDataStream &) const;
    static QicsDataItem *fromString(const QString &);
    static QicsDataItem *decode(QDataStream &);
};

class QicsDataString : QicsDataItem
{
%TypeHeaderCode
#include <QicsDataItem.h>
%End

public:
    QicsDataString();
    QicsDataString(const QString &);
    virtual ~QicsDataString();
    QicsDataString(const QicsDataString &);
    virtual QicsDataItem *create() const /Factory/;
    virtual QicsDataItem *clone() const /Factory/;
    static QString typeName();
    virtual QString typeString() const;
    virtual QicsDataItemType type() const;
    virtual bool setString(const QString &);
    virtual double number(bool *ok = 0) const;
    bool setData(const QString &);
    QString data() const;
    virtual const QString string() const;
    virtual QString format(const char *) const;
    virtual int compareTo(const QicsDataItem &) const;
    virtual void encode(QDataStream &) const;
    static QicsDataItem *decode(QDataStream &);
};

class QicsDataDate : QicsDataItem
{
%TypeHeaderCode
#include <QicsDataItem.h>
%End

public:
    QicsDataDate(Qt::DateFormat = Qt::TextDate);
    QicsDataDate(const QDate &, Qt::DateFormat = Qt::TextDate);
    QicsDataDate(int, int, int, Qt::DateFormat = Qt::TextDate);
    QicsDataDate(const QicsDataDate &);
    virtual QicsDataItem *create() const /Factory/;
    virtual QicsDataItem *clone() const /Factory/;
    static QString typeName();
    virtual QString typeString() const;
    virtual QicsDataItemType type() const;
    virtual const QString string() const;
    virtual bool setString(const QString &);
    virtual double number(bool *ok = 0) const;
    QDate data() const;
    void setData(const QDate &);
    virtual QString format(const char *) const;
    virtual Qt::DateFormat defaultDateFormat() const;
    virtual void setDefaultDateFormat(Qt::DateFormat);
    virtual int compareTo(const QicsDataItem &) const;
    virtual void encode(QDataStream &) const;
    static QicsDataItem *fromString(const QString &);
    static QicsDataItem *decode(QDataStream &);
};

class QicsDataTime : QicsDataItem
{
%TypeHeaderCode
#include <QicsDataItem.h>
%End

public:
    QicsDataTime(Qt::DateFormat = Qt::TextDate);
    QicsDataTime(const QTime &, Qt::DateFormat = Qt::TextDate);
    QicsDataTime(int, int, int, int, Qt::DateFormat);
    QicsDataTime(const QicsDataTime &);
    virtual QicsDataItem *create() const /Factory/;
    virtual QicsDataItem *clone() const /Factory/;
    static QString typeName();
    virtual QString typeString() const;
    virtual QicsDataItemType type() const;
    virtual const QString string() const;
    virtual bool setString(const QString &);
    virtual double number(bool *ok = 0) const;
    QTime data() const;
    void setData(const QTime &);
    virtual QString format(const char *) const;
    virtual Qt::DateFormat defaultDateFormat() const;
    virtual void setDefaultDateFormat(Qt::DateFormat);
    virtual int compareTo(const QicsDataItem &) const;
    virtual void encode(QDataStream &) const;
    static QicsDataItem *fromString(const QString &);
    static QicsDataItem *decode(QDataStream &);
};

class QicsDataDateTime : QicsDataItem
{
%TypeHeaderCode
#include <QicsDataItem.h>
%End

public:
    QicsDataDateTime(Qt::DateFormat = Qt::TextDate);
    QicsDataDateTime(const QDateTime &, Qt::DateFormat = Qt::TextDate);
    QicsDataDateTime(const QDate &, const QTime &, Qt::DateFormat = Qt::TextDate);
    QicsDataDateTime(const QicsDataDateTime &);
    virtual QicsDataItem *create() const /Factory/;
    virtual QicsDataItem *clone() const /Factory/;
    virtual QicsDataItemType type() const;
    static QString typeName();
    virtual QString typeString() const;
    virtual const QString string() const;
    virtual bool setString(const QString &);
    virtual double number(bool *ok = 0) const;
    QDateTime data() const;
    void setData(const QDateTime &);
    virtual QString format(const char *) const;
    virtual Qt::DateFormat defaultDateFormat() const;
    virtual void setDefaultDateFormat(Qt::DateFormat);
    virtual int compareTo(const QicsDataItem &) const;
    virtual void encode(QDataStream &) const;
    static QicsDataItem *fromString(const QString &);
    static QicsDataItem *decode(QDataStream &);
};

