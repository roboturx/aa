// QicsTable.sip generated by MetaSIP on Thu Aug 26 12:32:36 2010
//
// This file is part of the qicstable Python extension module.
//
// Copyright (c) 2004 - 2014
// 	Integrated Computer Solutions, Inc. <info@ics.com>
//
// This file is part of PyQicsTable.
//
// This copy of PyQicsTable is licensed for use under the terms of the
// PyQicsTable Commercial License Agreement version ICS-2.6.  See the file
// LICENSE for more details.
//
// PyQicsTable is supplied WITHOUT ANY WARRANTY; without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

//typedef int InT;
class QicsTable : QWidget, Qics
{
%TypeHeaderCode
#include <QicsTable.h>
%End

%TypeCode
#if SIP_VERSION < 0x040700
#include "sipqicstableQicsTableGrid.h"
#include "sipqicstableQicsHeaderGrid.h"
#include "sipqicstableQicsGridInfo.h"
#endif


// A helper class to hold the Python callable objects for a table.
class PyQicsTable_tableFoundries
{
public:
    PyQicsTable_tableFoundries(PyObject *rhf, PyObject *chf, PyObject *tgf, PyObject *hgf)
    {
        rhFoundry = rhf;
        chFoundry = chf;
        tgFoundry = tgf;
        hgFoundry = hgf;
    }

    PyObject *rhFoundry, *chFoundry, *tgFoundry, *hgFoundry;
};


// This is the C++ function that will dispatch to the different Python row
// header foundries.
static QicsDataModel *PyQicsTable_rhFoundry(int num_rows, int num_cols, void *key)
{
    QicsDataModel *dm = 0;
    PyQicsTable_tableFoundries *f = static_cast<PyQicsTable_tableFoundries *>(key);

    if (f)
    {
        int iserr = 0;

        SIP_BLOCK_THREADS

        PyObject *args = Py_BuildValue("ii", num_rows, num_cols);

        if (args != NULL)
        {
            PyObject *robj = PyObject_CallObject(f -> rhFoundry, args);

            Py_DECREF(args);

            if (robj != NULL)
            {
#if SIP_VERSION < 0x040800
                if (robj != Py_None && (dm = (QicsDataModel *)sipForceConvertTo_QicsDataModel(robj, &iserr)) != NULL)
					sipTransfer(robj, 1);
#else
				if (robj != Py_None && (dm = (QicsDataModel *)sipConvertToInstance(robj, sipClass_QicsDataModel, NULL, SIP_NO_CONVERTORS, NULL, &iserr)) != NULL)
					sipTransferTo(robj, robj);
#endif
                 Py_DECREF(robj);
            }
            else
                iserr = 1;
        }
        else
            iserr = 1;

        if (iserr)
            PyErr_Print();

        SIP_UNBLOCK_THREADS
    }

    return dm;
}


// This is the C++ function that will dispatch to the different Python column
// header foundries.
static QicsDataModel *PyQicsTable_chFoundry(int num_rows, int num_cols, void *key)
{
    QicsDataModel *dm = 0;
    PyQicsTable_tableFoundries *f = static_cast<PyQicsTable_tableFoundries *>(key);

    if (f)
    {
        int iserr = 0;

        SIP_BLOCK_THREADS

        PyObject *args = Py_BuildValue("ii", num_rows, num_cols);

        if (args != NULL)
        {
            PyObject *robj = PyObject_CallObject(f -> chFoundry, args);

            Py_DECREF(args);

            if (robj != NULL)
            {		
#if SIP_VERSION < 0x040800
                if (robj != Py_None && (dm = (QicsDataModel *)sipForceConvertTo_QicsDataModel(robj, &iserr)) != NULL)
					sipTransfer(robj, 1);
#else
				if (robj != Py_None && (dm = (QicsDataModel *)sipConvertToInstance(robj, sipClass_QicsDataModel, NULL, SIP_NO_CONVERTORS, NULL, &iserr)) != NULL)
					sipTransferTo(robj, robj);
#endif

                Py_DECREF(robj);
            }
            else
                iserr = 1;
        }
        else
            iserr = 1;

        if (iserr)
            PyErr_Print();

        SIP_UNBLOCK_THREADS
    }

    return dm;
}


// This is the C++ function that will dispatch to the different Python table
// grid foundries.
static QicsTableGrid *PyQicsTable_tgFoundry(QWidget *w, QicsGridInfo &info, int top_row, int left_column, void *key)
{
    QicsTableGrid *tg = 0;
    PyQicsTable_tableFoundries *f = static_cast<PyQicsTable_tableFoundries *>(key);

    if (f)
    {
        int iserr = 0;

        SIP_BLOCK_THREADS

        PyObject *args = sipBuildResult(NULL, "(MMii)", w, sipClass_QWidget, &info, sipClass_QicsGridInfo, top_row, left_column);

        if (args != NULL)
        {
            PyObject *robj = PyObject_CallObject(f -> tgFoundry, args);

            Py_DECREF(args);

            if (robj != NULL)
            {
#if SIP_VERSION < 0x040800
				if (robj != Py_None && (tg = (QicsTableGrid *)sipForceConvertTo_QicsTableGrid(robj, &iserr)) != NULL)
                    sipTransfer(robj, 1);
#else
				if (robj != Py_None && (tg = (QicsTableGrid *)sipConvertToInstance(robj, sipClass_QicsTableGrid, NULL, SIP_NO_CONVERTORS, NULL, &iserr)) != NULL)
					sipTransferTo(robj, robj);
#endif
				Py_DECREF(robj);
            }
            else
                iserr = 1;
        }
        else
            iserr = 1;

        if (iserr)
            PyErr_Print();

        SIP_UNBLOCK_THREADS
    }

    return tg;
}


// This is the C++ function that will dispatch to the different Python header
// grid foundries.
static QicsHeaderGrid *PyQicsTable_hgFoundry(QWidget *w, QicsGridInfo &info, Qics::QicsHeaderType type, void *key)
{
    QicsHeaderGrid *hg = 0;
    PyQicsTable_tableFoundries *f = static_cast<PyQicsTable_tableFoundries *>(key);

    if (f)
    {
        int iserr = 0;

        SIP_BLOCK_THREADS

        PyObject *args = sipBuildResult(NULL, "(MMe)", w, sipClass_QWidget, &info, sipClass_QicsGridInfo, type);

        if (args != NULL)
        {
            PyObject *robj = PyObject_CallObject(f -> hgFoundry, args);

            Py_DECREF(args);

            if (robj != NULL)
            {
#if SIP_VERSION < 0x040800
				if (robj != Py_None && (hg = (QicsHeaderGrid *)sipForceConvertTo_QicsHeaderGrid(robj, &iserr)) != NULL)
                    sipTransfer(robj, 1);
#else
				if (robj != Py_None && (hg = (QicsHeaderGrid *)sipConvertToInstance(robj, sipClass_QicsHeaderGrid, NULL, SIP_NO_CONVERTORS, NULL, &iserr)) != NULL)
					sipTransferTo(robj, robj);
#endif
                Py_DECREF(robj);
            }
            else
                iserr = 1;
        }
        else
            iserr = 1;

        if (iserr)
            PyErr_Print();

        SIP_UNBLOCK_THREADS
    }

    return hg;
}
%End

%ConvertToSubClassCode
    // Convert a QObject based instance to a more specific instance if possible.

    static sipStringTypeClassMap map[] = {
        {sipName_QicsCellCommon,              &sipClass_QicsCellCommon},
        {sipName_QicsCheckCellDisplay,        &sipClass_QicsCheckCellDisplay},
        {sipName_QicsComboCellDisplay,        &sipClass_QicsComboCellDisplay},
        {sipName_QicsDataModel,               &sipClass_QicsDataModel},
        {sipName_QicsGridInfo,                &sipClass_QicsGridInfo},
        {sipName_QicsScreenGrid,              &sipClass_QicsScreenGrid},
        {sipName_QicsScroller,                &sipClass_QicsScroller},
        {sipName_QicsTable,                   &sipClass_QicsTable},
        {sipName_QicsTextCellDisplay,         &sipClass_QicsTextCellDisplay},
    };
    QString classnamein = sipCpp -> objectName();

    sipClass = sipMapStringToClass(classnamein.toAscii(), map, sizeof (map)/sizeof (map[0]));
%End

public:
    QicsTable(QicsDataModel * = 0, QWidget * /TransferThis/ = 0);
    virtual ~QicsTable();
    QicsDataModel *dataModel() const;
    virtual void setDataModel(QicsDataModel *);
    QicsRow &rowRef(int);
    QicsRow *row(int, bool = true) /Factory/;
    QicsColumn &columnRef(int);
    QicsColumn *column(int, bool = true) /Factory/;
    QicsRepeatingRow &repeatingRowRef(int, unsigned int);
    QicsRepeatingRow *repeatingRow(int, unsigned int) /Factory/;
    QicsRepeatingColumn &repeatingColumnRef(int, unsigned int);
    QicsRepeatingColumn *repeatingColumn(int, unsigned int) /Factory/;
    QicsCell &cellRef(int, int);
    QicsCell *cell(int, int, bool = true) /Factory/;
    QicsMainGrid &mainGridRef();
    QicsMainGrid *mainGrid() /Factory/;
    QicsRowHeader &rowHeaderRef();
    QicsRowHeader *rowHeader() /Factory/;
    QicsColumnHeader &columnHeaderRef();
    QicsColumnHeader *columnHeader() /Factory/;
    QicsSelectionList *selectionList() const /Factory/;
    QicsSelectionList *selectionActionList() const /Factory/;
    void setSelectionList(QicsSelectionList &);
    void clearSelectionList();
    void addSelection(QicsSelection &);
    int margin() const;
    bool readOnly() const;
    QColor selectedForegroundColor() const;
    QColor selectedBackgroundColor() const;
    QColor editForegroundColor() const;
    QColor editBackgroundColor() const;
    QPixmap pixmap() const;
    int pixmapSpacing() const;
    QicsCellDisplay *displayer() const;
    QicsDataItemFormatter *formatter() const;
    int alignment() const;
    int textFlags() const;
    QValidator *validator() const;
    QString label() const;
    int maxLength() const;
//    int borderWidth() const;
//    Qics::QicsLineStyle borderStyle() const;
    QPen topBorderPen() const;
    QPen leftBorderPen() const;
    QPen rightBorderPen() const;
    QPen bottomBorderPen() const;
    virtual QicsRegion viewport() const;
    virtual QicsRegion mainGridViewport() const;
    virtual QicsRegion currentViewport() const;
    bool addCellSpan(QicsSpan);
    QicsSpanList *cellSpanList();
    bool horizontalGridLinesVisible() const;
    bool verticalGridLinesVisible() const;
    int horizontalGridLineWidth() const;
    int verticalGridLineWidth() const;
    Qics::QicsLineStyle horizontalGridLineStyle() const;
    Qics::QicsLineStyle verticalGridLineStyle() const;
    QPen horizontalGridLinePen() const;
    QPen verticalGridLinePen() const;
    bool drawPartialCells() const;
    Qics::QicsGridCellClipping gridCellClipping() const;
    Qics::QicsCellOverflowBehavior cellOverflowBehavior() const;
    int maxOverflowCells() const;
    int frameLineWidth() const;
    int frameStyle() const;
    Qics::QicsCurrentCellStyle currentCellStyle() const;
    int currentCellBorderWidth() const;
    bool clickToEdit() const;
    bool autoSelectCellContents() const;
    Qics::QicsTraversalKeyEditBehavior traversalKeyEditBehavior() const;
    Qt::Orientation enterTraversalDirection() const;
    Qt::Orientation tabTraversalDirection() const;
    QPixmap moreTextPixmap() const;
    bool dragEnabled() const;
    bool topHeaderVisible() const;
    bool bottomHeaderVisible() const;
    bool leftHeaderVisible() const;
    bool rightHeaderVisible() const;
    int tableMargin() const;
    int tableSpacing() const;
    int gridSpacing() const;
    bool ignoreModelSizeChanges() const;
    Qics::QicsSelectionPolicy selectionPolicy() const;
    void setSelectionPolicy(Qics::QicsSelectionPolicy);
    Qics::QicsRepaintBehavior repaintBehavior() const;
    Qics::QicsScrollBarMode hScrollBarMode() const;
    Qics::QicsScrollBarMode vScrollBarMode() const;
    void setHScrollBarMode(Qics::QicsScrollBarMode);
    void setVScrollBarMode(Qics::QicsScrollBarMode);
    void sortRows(QVector<int>, Qics::QicsSortOrder = Qics::Ascending, int = 0, int = -1, SIP_PYCALLABLE /AllowNone/ = 0);
%MethodCode
        Py_BEGIN_ALLOW_THREADS

        sipCpp -> QicsTable::sortRows(*a0, a1, a2, a3, PyQicsTable_getComparator(a4));
        PyQicsTable_releaseComparator(a4);

        Py_END_ALLOW_THREADS
%End

    void sortColumns(QVector<int>, Qics::QicsSortOrder = Qics::Ascending, int = 0, int = -1, SIP_PYCALLABLE /AllowNone/ = 0);
%MethodCode
        Py_BEGIN_ALLOW_THREADS

        sipCpp -> QicsTable::sortColumns(*a0, a1, a2, a3, PyQicsTable_getComparator(a4));
        PyQicsTable_releaseComparator(a4);

        Py_END_ALLOW_THREADS
%End

    void moveRows(int, const QVector<int> &);
    void moveColumns(int, const QVector<int> &);
    bool rowHeaderUsesModel() const;
    bool columnHeaderUsesModel() const;
    int topRow() const;
    int bottomRow() const;
    int leftColumn() const;
    int rightColumn() const;
    int visibleRows() const;
    int visibleColumns() const;
    const QicsCell *currentCell();
    bool editCurrentCell();
    void uneditCurrentCell();
    bool editCell(int, int);
    QAbstractSlider *horizontalScrollBar() const;
    QAbstractSlider *verticalScrollBar() const;
    QWidget *topTitleWidget() const;
    QWidget *bottomTitleWidget() const;
    QWidget *leftTitleWidget() const;
    QWidget *rightTitleWidget() const;
    QWidget *topLeftCornerWidget() const;
    QWidget *topRightCornerWidget() const;
    QWidget *bottomLeftCornerWidget() const;
    QWidget *bottomRightCornerWidget() const;
    Qics::QicsSelectionStyle selectionStyle() const;
    bool isNavigatorAllowed() const;
    QicsAbstractFilterDelegate* rowFilter(int column) const;
    void setRowFilter(int, QicsAbstractFilterDelegate *, bool);
    void removeRowFilter(int);
    void removeAllRowFilters();
    void removeRowFilter(int column, bool );
    bool isRowFiltered(int ) const;
    bool hasRowFilter(int ) const;
    QStringList     uniqueKeysForColumn(int, bool ) const;



public slots:
    void setMargin(int);
    void setReadOnly(bool);
    void setBackgroundColor(const QColor &);
    void setForegroundColor(const QColor &);
    void setSelectedForegroundColor(const QColor &);
    void setSelectedBackgroundColor(const QColor &);
    void setEditForegroundColor(const QColor &);
    void setEditBackgroundColor(const QColor &);
    void setPixmap(const QPixmap &);
    void setPixmapSpacing(int);
    void setDisplayer(QicsCellDisplay *);
    void setFormatter(QicsDataItemFormatter *);
    void setAlignment(int);
    void setTextFlags(int);
    void setValidator(QValidator *);
    void setLabel(const QString &);
    void setMaxLength(int);
//    void setBorderWidth(int);
//    void setBorderStyle(Qics::QicsLineStyle);
    void setBorderPen(const QPen &);
    virtual void setViewport(const QicsRegion &);
    void removeCellSpan(int, int);
    void setHorizontalGridLinesVisible(bool);
    void setVerticalGridLinesVisible(bool);
    void setHorizontalGridLineWidth(int);
    void setVerticalGridLineWidth(int);
    void setHorizontalGridLineStyle(Qics::QicsLineStyle);
    void setVerticalGridLineStyle(Qics::QicsLineStyle);
    void setHorizontalGridLinePen(const QPen &);
    void setVerticalGridLinePen(const QPen &);
    void setDrawPartialCells(bool);
    void setGridCellClipping(Qics::QicsGridCellClipping);
    void setCellOverflowBehavior(Qics::QicsCellOverflowBehavior);
    void setMaxOverflowCells(int);
    void setFrameStyle(int);
    void setFrameLineWidth(int);
    void setCurrentCellStyle(Qics::QicsCurrentCellStyle);
    void setCurrentCellBorderWidth(int);
    void setClickToEdit(bool);
    void setAutoSelectCellContents(bool);
    void setTraversalKeyEditBehavior(Qics::QicsTraversalKeyEditBehavior);
    void setEnterTraversalDirection(Qt::Orientation);
    void setTabTraversalDirection(Qt::Orientation);
    void setMoreTextPixmap(const QPixmap &);
    void setDragEnabled(bool);
    void setTopHeaderVisible(bool);
    void setBottomHeaderVisible(bool);
    void setLeftHeaderVisible(bool);
    void setRightHeaderVisible(bool);
    void setTableMargin(int);
    void setTableSpacing(int);
    void setGridSpacing(int);
    void setRowHeaderUsesModel(bool);
    void setColumnHeaderUsesModel(bool);
    void setIgnoreModelSizeChanges(bool);
    void setTopTitleWidget(QWidget * /Transfer/);
    void setBottomTitleWidget(QWidget * /Transfer/);
    void setLeftTitleWidget(QWidget * /Transfer/);
    void setRightTitleWidget(QWidget * /Transfer/);
    void setTopLeftCornerWidget(QWidget * /Transfer/);
    void setTopRightCornerWidget(QWidget * /Transfer/);
    void setBottomLeftCornerWidget(QWidget * /Transfer/);
    void setBottomRightCornerWidget(QWidget * /Transfer/);
    void setCurrentCell(int, int);
    void scroll(Qics::QicsScrollDirection, int);
    void freezeTopRows(int);
    void freezeBottomRows(int);
    void unfreezeTopRows();
    void unfreezeBottomRows();
    void freezeLeftColumns(int);
    void freezeRightColumns(int);
    void unfreezeLeftColumns();
    void unfreezeRightColumns();
    void toggleRowHeightExpansion(int);
    void toggleColumnWidthExpansion(int);
    void setTopRow(int);
    void setLeftColumn(int);
    void setRepaintBehavior(Qics::QicsRepaintBehavior);
    void setVisibleRows(int);
    void setVisibleColumns(int);
    bool traverseToCell(int, int);
    void traverseToBeginningOfTable();
    void traverseToEndOfTable();
    void traverseToBeginningOfRow();
    void traverseToEndOfRow();
    void traverseLeft();
    void traverseRight();
    void traverseUp();
    void traverseDown();
    void deleteColumn(int);
    void addColumns(int);
    void insertColumn(int);
    void deleteRow(int);
    void addRows(int);
    void insertRow(int);
    virtual void print(QPrinter *);
    virtual void print(QPrinter *, const QicsRegion &);
    virtual void cut();
    virtual void copy();
    virtual void paste();
    void setDefaultRowHeightInPixels(int);
    void setDefaultRowHeightInChars(int);
    void setDefaultColumnWidthInPixels(int);
    void setDefaultColumnWidthInChars(int);
    void setSelectionStyle(Qics::QicsSelectionStyle);
    void setNavigatorAllowed(bool);


signals:
    void pressed(int, int, int, const QPoint &);
    void clicked(int, int, int, const QPoint &);
    void doubleClicked(int, int, int, const QPoint &);
    void currentCellChanged(int, int);
    void selectionListChanged(bool);
    void valueChanged(int, int);

public:
    // We need a completely different Python signature (ie. one with a
    // different number of arguments) which MetaSIP can't yet handle.  So we do
    // this entirely by hand.
    QicsTable(SIP_PYCALLABLE /AllowNone/, SIP_PYCALLABLE /AllowNone/,
              SIP_PYCALLABLE /AllowNone/, SIP_PYCALLABLE /AllowNone/,
              QicsDataModel * = 0, QWidget * /TransferThis/ = 0)
        [(void *, QicsDataModel::FoundryWithKey, QicsDataModel::FoundryWithKey,
          QicsTableGrid::FoundryWithKey,
          QicsHeaderGrid::FoundryWithKey, QicsDataModel *, QWidget *)];
%MethodCode
    // Save the Python callables.
    PyQicsTable_tableFoundries *tf = new PyQicsTable_tableFoundries(a0, a1, a2, a3);

    // Create the instance with the C++ dispatchers.
    Py_BEGIN_ALLOW_THREADS

    QicsDataModel::FoundryWithKey rhf, chf;
    QicsTableGrid::FoundryWithKey tgf;
    QicsHeaderGrid::FoundryWithKey hgf;

    // Only pass the C++ dispatcher if there is a corresponding Python
    // callable.
    rhf = (a0 != Py_None) ? PyQicsTable_rhFoundry : 0;
    chf = (a1 != Py_None) ? PyQicsTable_chFoundry : 0;
    tgf = (a2 != Py_None) ? PyQicsTable_tgFoundry : 0;
    hgf = (a3 != Py_None) ? PyQicsTable_hgFoundry : 0;

    sipCpp = new sipQicsTable(tf, rhf, chf, tgf, hgf, a4, a5);
    Py_END_ALLOW_THREADS

%End
    protected:
	void showNavigator();
};

