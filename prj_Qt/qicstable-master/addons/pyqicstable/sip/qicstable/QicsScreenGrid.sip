// QicsScreenGrid.sip generated by MetaSIP on Thu Aug 26 12:32:36 2010
//
// This file is part of the qicstable Python extension module.
//
// Copyright (c) 2004 - 2014
// 	Integrated Computer Solutions, Inc. <info@ics.com>
//
// This file is part of PyQicsTable.
//
// This copy of PyQicsTable is licensed for use under the terms of the
// PyQicsTable Commercial License Agreement version ICS-2.6.  See the file
// LICENSE for more details.
//
// PyQicsTable is supplied WITHOUT ANY WARRANTY; without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


class QicsScreenGrid : QFrame, QicsGrid
{
%TypeHeaderCode
#include <QicsScreenGrid.h>
%End

public:
    QicsScreenGrid(QWidget * /TransferThis/, QicsGridInfo &, int = 0, int = 0);
    virtual ~QicsScreenGrid();
    bool isMainGrid() const;
    virtual void setViewport(const QicsRegion &);
    int lastPageStartRow();
    int lastPageStartColumn();
    int topRow() const;
    int bottomRow() const;
    int leftColumn() const;
    int rightColumn() const;
    QicsICell cellAt(int, int, bool) const;
    int rowAt(int, bool) const;
    int columnAt(int, bool) const;
    void scrollLeft(int);
    void scrollRight(int);
    void scrollUp(int);
    void scrollDown(int);
    bool isHeightFixed() const;
    bool isWidthFixed() const;
    void fixHeightToViewport(bool);
    void fixWidthToViewport(bool);
    int visibleRows() const;
    int visibleColumns() const;
//    virtual bool requestCellOverflow(const QicsRegion &, const QRect &, QicsRegion &, QRect &);
    QicsICell currentCell() const;
    QString tooltipText(const QicsICell &) const;
    virtual void orderRowsBy(QVector <int>, Qics::QicsSortOrder = Qics::Ascending, SIP_PYCALLABLE /AllowNone/ = 0) [void (QVector <int>, Qics::QicsSortOrder = Qics::Ascending, DataItemComparator = 0)];
%MethodCode
        Py_BEGIN_ALLOW_THREADS

        sipCpp -> QicsScreenGrid::orderRowsBy(*a0, a1, PyQicsTable_getComparator(a2));
        PyQicsTable_releaseComparator(a2);

        Py_END_ALLOW_THREADS
%End

%VirtualCatcherCode
        PyObject *result = sipCallMethod(&sipIsErr, sipMethod, "BeT", &a0, a1, a2, PyQicsTable_wrapComparator);

        if (result != NULL)
        {
            sipParseResult(&sipIsErr, sipMethod, result, "Z");
            Py_DECREF(result);
        }
%End

    virtual void orderColumnsBy(QVector<int>, Qics::QicsSortOrder = Qics::Ascending, SIP_PYCALLABLE /AllowNone/ = 0) [void (QVector<int>, Qics::QicsSortOrder = Qics::Ascending, DataItemComparator = 0)];
%MethodCode
        Py_BEGIN_ALLOW_THREADS

        sipCpp -> QicsScreenGrid::orderColumnsBy(*a0, a1, PyQicsTable_getComparator(a2));
        PyQicsTable_releaseComparator(a2);

        Py_END_ALLOW_THREADS
%End

%VirtualCatcherCode
        PyObject *result = sipCallMethod(&sipIsErr, sipMethod, "BeT", &a0, a1, a2, PyQicsTable_wrapComparator);

        if (result != NULL)
        {
            sipParseResult(&sipIsErr, sipMethod, result, "Z");
            Py_DECREF(result);
        }
%End

    virtual bool handleTraversalKeys(QKeyEvent *);

public slots:
    void setTopRow(int);
    void setLeftColumn(int);
    void setIsMainGrid(bool);
    virtual void reset();
    virtual void recomputeAndDraw();
    virtual void resetAndDraw();
    virtual void redraw();
    virtual void redraw(QicsRegion);
    virtual void redraw(QicsSpan);
    void setVisibleRows(int);
    void setVisibleColumns(int);
    void drawHeaderResizeBar(int, int, Qics::QicsHeaderType);
    void traverse(Qics::QicsScrollDirection);
    virtual bool traverseToCell(int, int, bool = true);
    virtual bool traverseToBeginningOfTable();
    virtual bool traverseToEndOfTable();
    virtual bool traverseToBeginningOfRow();
    virtual bool traverseToEndOfRow();
    virtual bool traverseLeft();
    virtual bool traverseRight();
    virtual bool traverseUp();
    virtual bool traverseDown();
    bool editCell(int, int);
    bool editCurrentCell();
    void uneditCurrentCell();
    bool editable() const;
    void setEditable(bool);

protected:
    virtual void dropEvent(QDropEvent *);
    virtual void dropAt(QDropEvent *, const QicsICell &);

signals:
    void pressed(int, int, int, const QPoint &);
    void clicked(int, int, int, const QPoint &);
    void doubleClicked(int, int, int, const QPoint &);
    void scrollRequest(Qics::QicsScrollDirection, int);
    void newBoundsInfo();
    void uneditRequest();

protected:
    void setCurrentCell(const QicsICell &);
    virtual void layout();
    virtual void computeCellPositions();
//    virtual void drawContents(QPainter *);
    virtual QRect paintRegion(const QRect &, QPainter *);//API-modified
    virtual QRect paintRegion(const QicsRegion &, QPainter *,  bool);//API-modified
    virtual QRect drawCell(int, int, int, int, bool, QPainter *, QicsGrid::DrawCellMode);//API-modified
    virtual bool prepareToDraw(int, int, const QRect &, QPainter *);
    virtual void computeLastPage();
    virtual QSize sizeHint() const;
    virtual QSize minimumSizeHint() const;
    virtual void resizeEvent(QResizeEvent *);
    virtual void mousePressEvent(QMouseEvent *);
    virtual void mouseReleaseEvent(QMouseEvent *);
    virtual void mouseDoubleClickEvent(QMouseEvent *);
    virtual void mouseMoveEvent(QMouseEvent *);
    virtual void keyPressEvent(QKeyEvent *);
    virtual void keyReleaseEvent(QKeyEvent *);
    virtual void handleMousePressEvent(const QicsICell &, QMouseEvent *);
    virtual void handleMouseReleaseEvent(const QicsICell &, QMouseEvent *);
    virtual void handleMouseDoubleClickEvent(const QicsICell &, QMouseEvent *);
    virtual void handleMouseMoveEvent(const QicsICell &, QMouseEvent *);
    virtual void handleKeyPressEvent(const QicsICell &, QKeyEvent *);
    virtual void handleKeyReleaseEvent(const QicsICell &, QKeyEvent *);
    bool isCellVisible(int, int) const;
    void makeCellFullyVisible(int, int);
    void updateViewport();
    void updateLineWidth();
    void updateFrameStyle();
    //void traverse(Qt::Orientation, bool);
    virtual void selectCell(int, int);
    void placeEntryWidget();
    virtual void prepareDrag(const QicsICell &, Qt::DropAction);
    // For Qt4 QDragObject::DragMode is Qt::DropAction
    virtual void startDrag(Qt::DropAction);
    virtual void finishDrag(Qt::DropAction, bool, QWidget *);
    // returned type is QMimeData (Qt4), not QDragObject (Qt3)
    QMimeData *dragObject(Qt::DropAction);
    virtual bool canDropAt(QDragMoveEvent *, const QicsICell &) const;
};

